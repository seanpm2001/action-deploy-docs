export const blog_in = [
	{
		name: "2016-11-26-frameworks-without-the-framework.md",
		content:
			"---\ntitle: \"Frameworks without the framework: why didn't we think of this sooner?\"\ndescription: You can't write serious applications in vanilla JavaScript without hitting a complexity wall. But a compiler can do it for you.\nauthor: Rich Harris\nauthorURL: https://twitter.com/Rich_Harris\n---\n\n> Wait, this new framework has a *runtime*? Ugh. Thanks, I'll pass.\n> **– front end developers in 2018**\n\nWe're shipping too much code to our users. Like a lot of front end developers, I've been in denial about that fact, thinking that it was fine to serve 100kb of JavaScript on page load – just use [one less .jpg!](https://twitter.com/miketaylr/status/227056824275333120) – and that what *really* mattered was performance once your app was already interactive.\n\nBut I was wrong. 100kb of .js isn't equivalent to 100kb of .jpg. It's not just the network time that'll kill your app's startup performance, but the time spent parsing and evaluating your script, during which time the browser becomes completely unresponsive. On mobile, those milliseconds rack up very quickly.\n\nIf you're not convinced that this is a problem, follow [Alex Russell](https://twitter.com/slightlylate) on Twitter. Alex [hasn't been making many friends in the framework community lately](https://twitter.com/slightlylate/status/728355959022587905), but he's not wrong. But the proposed alternative to using frameworks like Angular, React and Ember – [Polymer](https://www.polymer-project.org/1.0/) – hasn't yet gained traction in the front end world, and it's certainly not for a lack of marketing.\n\nPerhaps we need to rethink the whole thing.\n\n\n## What problem do frameworks *really* solve?\n\nThe common view is that frameworks make it easier to manage the complexity of your code: the framework abstracts away all the fussy implementation details with techniques like virtual DOM diffing. But that's not really true. At best, frameworks *move the complexity around*, away from code that you had to write and into code you didn't.\n\nInstead, the reason that ideas like React are so wildly and deservedly successful is that they make it easier to manage the complexity of your *concepts*. Frameworks are primarily a tool for structuring your thoughts, not your code.\n\nGiven that, what if the framework *didn't actually run in the browser*? What if, instead, it converted your application into pure vanilla JavaScript, just like Babel converts ES2016+ to ES5? You'd pay no upfront cost of shipping a hefty runtime, and your app would get seriously fast, because there'd be no layers of abstraction between your app and the browser.\n\n\n## Introducing Svelte\n\nSvelte is a new framework that does exactly that. You write your components using HTML, CSS and JavaScript (plus a few extra bits you can [learn in under 5 minutes](https://v2.svelte.dev/guide)), and during your build process Svelte compiles them into tiny standalone JavaScript modules. By statically analysing the component template, we can make sure that the browser does as little work as possible.\n\nThe [Svelte implementation of TodoMVC](https://svelte-todomvc.surge.sh/) weighs 3.6kb zipped. For comparison, React plus ReactDOM *without any app code* weighs about 45kb zipped. It takes about 10x as long for the browser just to evaluate React as it does for Svelte to be up and running with an interactive TodoMVC.\n\nAnd once your app *is* up and running, according to [js-framework-benchmark](https://github.com/krausest/js-framework-benchmark) **Svelte is fast as heck**. It's faster than React. It's faster than Vue. It's faster than Angular, or Ember, or Ractive, or Preact, or Riot, or Mithril. It's competitive with Inferno, which is probably the fastest UI framework in the world, for now, because [Dominic Gannaway](https://twitter.com/trueadm) is a wizard. (Svelte is slower at removing elements. We're [working on it](https://github.com/sveltejs/svelte/issues/26).)\n\nIt's basically as fast as vanilla JS, which makes sense because it *is* vanilla JS – just vanilla JS that you didn't have to write.\n\n\n## But that's not the important thing\n\nWell, it *is* important – performance matters a great deal. What's really exciting about this approach, though, is that we can finally solve some of the thorniest problems in web development.\n\nConsider interoperability. Want to `npm install cool-calendar-widget` and use it in your app? Previously, you could only do that if you were already using (a correct version of) the framework that the widget was designed for – if `cool-calendar-widget` was built in React and you're using Angular then, well, hard cheese. But if the widget author used Svelte, apps that use it can be built using whatever technology you like. (On the TODO list: a way to convert Svelte components into web components.)\n\nOr [code splitting](https://twitter.com/samccone/status/797528710085652480). It's a great idea (only load the code the user needs for the initial view, then get the rest later), but there's a problem – even if you only initially serve one React component instead of 100, *you still have to serve React itself*. With Svelte, code splitting can be much more effective, because the framework is embedded in the component, and the component is tiny.\n\nFinally, something I've wrestled with a great deal as an open source maintainer: your users always want *their* features prioritised, and underestimate the cost of those features to people who don't need them. A framework author must always balance the long-term health of the project with the desire to meet their users' needs. That's incredibly difficult, because it's hard to anticipate – much less articulate – the consequences of incremental bloat, and it takes serious soft skills to tell people (who may have been enthusiastically evangelising your tool up to that point) that their feature isn't important enough. But with an approach like Svelte's, many features can be added with absolutely no cost to people who don't use them, because the code that implements those features just doesn't get generated by the compiler if it's unnecessary.\n\n\n## We're just getting started\n\nSvelte is very new. There's a lot of work still left to do – creating build tool integrations, adding a server-side renderer, hot reloading, transitions, more documentation and examples, starter kits, and so on.\n\nBut you can already build rich components with it, which is why we've gone straight to a stable 1.0.0 release. [Read the guide](https://v2.svelte.dev/guide), [try it out in the REPL](/repl), and head over to [GitHub](https://github.com/sveltejs/svelte) to help kickstart the next era of front end development.\n",
	},
	{
		name: "2017-08-07-the-easiest-way-to-get-started.md",
		content:
			"---\ntitle: The easiest way to get started with Svelte\ndescription: This'll only take a minute.\nauthor: Rich Harris\nauthorURL: https://twitter.com/Rich_Harris\n---\n\nSvelte is a [new kind of framework](/blog/frameworks-without-the-framework). Rather than putting a `<script src='svelte.js'>` tag on the page, or bringing it into your app with `import` or `require`, Svelte is a compiler that works behind the scenes to turn your component files into beautifully optimised JavaScript.\n\nBecause of that, getting started with it can be a little bit confusing at first. How, you might reasonably ask, do you make a Svelte app?\n\n\n## 1. Use the REPL\n\nThe [Svelte REPL](repl) is the easiest way to begin. You can choose from a list of examples to get you started, and tweak them until they do what you want.\n\n<aside><p>You'll need to have <a href=\"https://nodejs.org/\">Node.js</a> installed, and know how to use the terminal</p></aside>\n\nAt some point, your app will outgrow the REPL. Click the **download** button to save a `svelte-app.zip` file to your computer and uncompress it.\n\nOpen a terminal window and set the project up...\n\n```bash\ncd /path/to/svelte-app\nnpm install\n```\n\n...then start up a development server:\n\n```bash\nnpm run dev\n```\n\nThis will serve your app on [localhost:5000](http://localhost:5000) and rebuild it with [Rollup](https://rollupjs.org) every time you make a change to the files in `svelte-app/src`.\n\n\n## 2. Use degit\n\nWhen you download from the REPL, you're getting a customised version of the [sveltejs/template](https://github.com/sveltejs/template) repo. You can skip messing around with zip files by using [degit](https://github.com/Rich-Harris/degit), a project scaffolding tool.\n\nIn the terminal, you can instantly create a new project like so:\n\n```bash\nnpx degit sveltejs/template my-svelte-project\ncd my-svelte-project\nnpm install\nnpm run dev\n```\n\nThis will create a new project in the `my-svelte-project` directory, install its dependencies, and start a server on http://localhost:5000.\n\nOnce you've tinkered a bit and understood how everything fits together, you can fork [sveltejs/template](https://github.com/sveltejs/template) and start doing this instead:\n\n```bash\nnpx degit your-name/template my-new-project\n```\n\nAnd that's it! Do `npm run build` to create a production-ready version of your app, and check the project template's [README](https://github.com/sveltejs/template/blob/master/README.md) for instructions on how to easily deploy your app to the web with [Now](https://zeit.co/now) or [Surge](http://surge.sh/).\n\nYou're not restricted to using Rollup — there are also integrations for [webpack](https://github.com/sveltejs/svelte-loader), [Browserify](https://github.com/tehshrike/sveltify) and others, or you can use the [Svelte CLI](https://github.com/sveltejs/svelte-cli) (Update from 2019: with Svelte 3 the CLI was deprecated and we now use [sirv-cli](https://www.npmjs.com/package/sirv-cli) in our template. Feel free to use whatever tool you like!) or the [API](https://github.com/sveltejs/svelte/tree/v2#api) directly. If you make a project template using one of these tools, please share it with the [Svelte Discord chatroom](chat), or via [@sveltejs](https://twitter.com/sveltejs) on Twitter!\n",
	},
	{
		name: "2017-09-06-the-zen-of-just-writing-css.md",
		content:
			"---\ntitle: The zen of Just Writing CSS\ndescription: I would say this is the future, but we're already doing it.\nauthor: Rich Harris\nauthorURL: https://twitter.com/Rich_Harris\n---\n\nIt's fashionable to dislike CSS. There are lots of reasons why that's the case, but it boils down to this: CSS is *unpredictable*. If you've never had the experience of tweaking a style rule and accidentally breaking some layout that you thought was completely unrelated — usually when you're trying to ship — then you're either new at this or you're a much better programmer than the rest of us.\n\nSo the JavaScript community rolled up its sleeves and got to work. Over the last couple of years, there's been a Cambrian explosion of libraries aimed at making CSS behave, collectively referred to as *CSS-in-JS*.\n\nWhat you might not realise is that **the biggest problems with CSS can be solved without CSS-in-JS**. Without those problems, writing CSS isn't just tolerable — it's enjoyable. And you don't have to find solutions to the additional problems that CSS-in-JS introduces.\n\nThis article isn't in any way intended as criticism of the hard work the CSS-in-JS community has done. It's one of the most active corners of the JS ecosystem, and new ideas are springing up every week. Instead, my purpose is to illustrate why an alternative approach — based on Single File Components with real CSS — is so damn delightful.\n\n\n## The biggest problem with CSS\n\nEverything in CSS is global. Because of that, styles intended for one bit of markup often end up affecting another. Because of *that*, developers often resort to wild namespacing conventions (not 'rules', since they're very difficult to enforce) that mostly just increase your risk of RSI.\n\nIt gets worse when you're working on a team. No-one dares touch styles authored by someone else, because it's often unclear what they're doing, what markup they apply to, and what disasters will unfold if you remove them.\n\nThe consequence of all this is the **append-only stylesheet**. There's no way of knowing which code can safely be removed, so it's common to undo some existing style with another, more specific style — even on relatively small projects.\n\n\n## Single File Components change all that\n\nThe idea behind SFCs is simple: you write your components in an HTML file that (optionally) contains a `<style>` and `<script>` attribute describing the component's styles and behaviour. Svelte, Ractive, Vue and Polymer all follow this basic pattern.\n\n<aside>\n\t<p><a href=\"blog/frameworks-without-the-framework\">Read the introductory blog post</a> if you're new to Svelte. Or <a href=\"https://twitter.com/padolsey/status/899717303234908160\">read</a> <a href=\"https://twitter.com/sveltejs/status/901818357644701696\">the</a> <a href=\"https://twitter.com/sveltejs/status/901818106309476352\">testimonials</a>.</p>\n</aside>\n\n(For the rest of this article we'll be using Svelte, obviously. But if the idea of using a template language makes you shudder — your fears are misplaced, but that's a topic for another day — then just use Vue which lets you use JSX in your SFCs.)\n\nSeveral wonderful things happen as a result:\n\n* Your styles are *scoped to the component*. No more leakage, no more unpredictable cascade. And no more sesquipedalian classnames designed to prevent conflicts.\n* You don't need to go spelunking through your folder structure to find the rules that are breaking your stuff.\n* The compiler (in Svelte's case) can **identify and remove unused styles**. No more append-only stylesheets!\n\nLet's see what that looks like in practice.\n\n<figure>\n\t<video controls poster='https://svelte-technology-assets.surge.sh/just-write-css.jpg'>\n\t\t<source type='video/mp4' src='https://svelte-technology-assets.surge.sh/just-write-css.mp4'>\n\t</video>\n\n\t<figcaption>\n\t\tIs this what they mean by 'use the platform'?\n\t</figcaption>\n</figure>\n\nEvery code editor already knows about CSS, so there's a good chance that you'll get autocomplete, linting, syntax highlighting and so on — all without additional JS-fatigue-inducing tools.\n\nAnd because it's real CSS, rather than some camelCased quotes-everywhere impostor, we can take advantage of the 'tweak in devtools, paste back into our source code' workflow, which I personally couldn't live without. Notice that we get CSS sourcemaps out of the box, so you can instantly pinpoint the lines in question. It's hard to overstate the importance of this: when you're in WYSIWYG mode, you're not thinking in terms of your component tree, so having a robust way to figure out *where these damn styles came from* is essential. Doubly so if someone else originally wrote the component. (I promise you, this is the single biggest productivity boost to your CSS workflow. If you're writing styles without sourcemaps, you are almost certainly wasting a lot of time. I know I was.)\n\nSvelte transforms your selectors (using an attribute that's also applied to affected elements, though the exact mechanism is unimportant and subject to change) to achieve the scoping. It warns on and removes any unused rules, then it minifies the result and lets you write it out to a `.css` file. There's also an experimental new option to compile to web components, using shadow DOM to encapsulate the styles, if that's your jam.\n\nThis is all possible because your CSS is parsed (with [css-tree](https://github.com/csstree/csstree)) and statically analysed in the context of your markup. Static analysis opens the doors to all kinds of exciting future possibilities — smarter optimisations, a11y hints — that are much harder if your styles are computed dynamically at runtime. We're just getting started.\n\n\n## But we can add tools to do [x]!\n\nIf your reaction to the video was 'fine, but if we use TypeScript and write plugins for each editor then we can get all the autocomplete and syntax highlighting stuff' — in other words, if you believe that in order to achieve parity with CSS it makes sense to build, document, promote and maintain a fleet of ancillary projects — then, well, you and I may never see eye to eye!\n\n\n## We don't have all the answers — yet\n\nHaving said all that, CSS-in-JS does point to answers to some lingering questions:\n\n* How can we install styles from npm?\n* How can we reuse constants that are defined in a single place?\n* How can we compose declarations?\n\nPersonally, I haven't found these issues to outweigh the benefits of the approach outlined above. You may well have a different set of priorities, and they may be reason enough for you to abandon CSS.\n\nBut at the end of the day, you have to know CSS anyway. Love it or loathe it, you must at least *learn* it. As custodians of the web, we have a choice: create abstractions that steepen the web dev learning curve yet further, or work together to fix the bad parts of CSS. I know which I choose.\n",
	},
	{
		name: "2017-12-31-sapper-towards-the-ideal-web-app-framework.md",
		content:
			"---\ntitle: \"Sapper: Towards the ideal web app framework\"\ndescription: Taking the next-plus-one step\nauthor: Rich Harris\nauthorURL: https://twitter.com/Rich_Harris\n---\n\n> Quickstart for the impatient: [the Sapper docs](https://sapper.svelte.dev), and the [starter template](https://github.com/sveltejs/sapper-template)\n\nIf you had to list the characteristics of the perfect Node.js web application framework, you'd probably come up with something like this:\n\n1. It should do server-side rendering, for fast initial loads and no caveats around SEO\n2. As a corollary, your app's codebase should be universal — write once for server *and* client\n3. The client-side app should *hydrate* the server-rendered HTML, attaching event listeners (and so on) to existing elements rather than re-rendering them\n4. Navigating to subsequent pages should be instantaneous\n5. Offline, and other Progressive Web App characteristics, must be supported out of the box\n6. Only the JavaScript and CSS required for the first page should load initially. That means the framework should do automatic code-splitting at the route level, and support dynamic `import(...)` for more granular manual control\n7. No compromise on performance\n8. First-rate developer experience, with hot module reloading and all the trimmings\n9. The resulting codebase should be easy to grok and maintain\n10. It should be possible to understand and customise every aspect of the system — no webpack configs locked up in the framework, and as little hidden 'plumbing' as possible\n11. Learning the entire framework in under an hour should be easy, and not just for experienced developers\n\n[Next.js](https://github.com/zeit/next.js) is close to this ideal. If you haven't encountered it yet, I strongly recommend going through the tutorials at [learnnextjs.com](https://learnnextjs.com). Next introduced a brilliant idea: all the pages of your app are files in a `your-project/pages` directory, and each of those files is just a React component.\n\nEverything else flows from that breakthrough design decision. Finding the code responsible for a given page is easy, because you can just look at the filesystem rather than playing 'guess the component name'. Project structure bikeshedding is a thing of the past. And the combination of SSR (server-side rendering) and code-splitting — something the React Router team [gave up on](https://reacttraining.com/react-router/web/guides/code-splitting), declaring 'Godspeed those who attempt the server-rendered, code-split apps' — is trivial.\n\nBut it's not perfect. As churlish as it might be to list the flaws in something *so, so good*, there are some:\n\n* Next uses something called 'route masking' to create nice URLs (e.g. `/blog/hello-world` instead of `/post?slug=hello-world`). This undermines the guarantee about directory structure corresponding to app structure, and forces you to maintain configuration that translates between the two forms\n* All your routes are assumed to be universal 'pages'. But it's very common to need routes that only render on the server, such as a 301 redirect or an [API endpoint](/blog/sapper-towards-the-ideal-web-app-framework.json) that serves the data for your pages, and Next doesn't have a great solution for this. You can add logic to your `server.js` file to handle these cases, but it feels at odds with the declarative approach taken for pages\n* To use the client-side router, links can't be standard `<a>` tags. Instead, you have to use framework-specific `<Link>` components, which is impossible in the markdown content for a blog post such as this one, for example\n\nThe real problem, though, is that all that goodness comes for a price. The simplest possible Next app — a single 'hello world' page that renders some static text — involves 66kb of gzipped JavaScript. Unzipped, it's 204kb, which is a non-trivial amount of code for a mobile device to parse at a time when performance is a critical factor determining whether or not your users will stick around. And that's the *baseline*.\n\nWe can do better!\n\n\n## The compiler-as-framework paradigm shift\n\n[Svelte introduced a radical idea](blog/frameworks-without-the-framework): what if your UI framework wasn't a framework at all, but a compiler that turned your components into standalone JavaScript modules? Instead of using a library like React or Vue, which knows nothing about your app and must therefore be a one-size-fits-all solution, we can ship highly-optimised vanilla JavaScript. Just the code your app needs, and without the memory and performance overhead of solutions based on a virtual DOM.\n\nThe JavaScript world is [moving towards this model](https://tomdale.net/2017/09/compilers-are-the-new-frameworks/). [Stencil](https://stenciljs.com), a Svelte-inspired framework from the Ionic team, compiles to web components. [Glimmer](https://glimmerjs.com) *doesn't* compile to standalone JavaScript (the pros and cons of which deserve a separate blog post), but the team is doing some fascinating research around compiling templates to bytecode. (React is [getting in on the action](https://twitter.com/trueadm/status/944908776896978946), though their current research focuses on optimising your JSX app code, which is arguably more similar to the ahead-of-time optimisations that Angular, Ractive and Vue have been doing for a few years.)\n\nWhat happens if we use the new model as a starting point?\n\n\n## Introducing Sapper\n\n<aside><p>The <a href=\"https://sapper.svelte.dev/docs#Why_the_name\">name comes from</a> the term for combat engineers, and is also short for Svelte app maker</p></aside>\n\n[Sapper](https://sapper.svelte.dev) is the answer to that question. **Sapper is a Next.js-style framework that aims to meet the eleven criteria at the top of this article while dramatically reducing the amount of code that gets sent to the browser.** It's implemented as Express-compatible middleware, meaning it's easy to understand and customise.\n\nThe same 'hello world' app that took 204kb with React and Next weighs just 7kb with Sapper. That number is likely to fall further in the future as we explore the space of optimisation possibilities, such as not shipping any JavaScript *at all* for pages that aren't interactive, beyond the tiny Sapper runtime that handles client-side routing.\n\nWhat about a more 'real world' example? Conveniently, the [RealWorld](https://github.com/gothinkster/realworld) project, which challenges frameworks to develop an implementation of a Medium clone, gives us a way to find out. The [Sapper implementation](https://github.com/sveltejs/realworld) takes 39.6kb (11.8kb zipped) to render an interactive homepage.\n\n<aside><p>Code-splitting isn't free — if the reference implementation used code-splitting, it would be larger still</p></aside>\n\nThe entire app costs 132.7kb (39.9kb zipped), which is significantly smaller than the reference React/Redux implementation at 327kb (85.7kb), but even if it was as large it would *feel* faster because of code-splitting. And that's a crucial point. We're told we need to code-split our apps, but if your app uses a traditional framework like React or Vue then there's a hard lower bound on the size of your initial code-split chunk — the framework itself, which is likely to be a significant portion of your total app size. With the Svelte approach, that's no longer the case.\n\nBut size is only part of the story. Svelte apps are also extremely performant and memory-efficient, and the framework includes powerful features that you would sacrifice if you chose a 'minimal' or 'simple' UI library.\n\n\n## Trade-offs\n\nThe biggest drawback for many developers evaluating Sapper would be 'but I like React, and I already know how to use it', which is fair.\n\nIf you're in that camp, I'd invite you to at least try alternative frameworks. You might be pleasantly surprised! The [Sapper RealWorld](https://github.com/sveltejs/realworld) implementation totals 1,201 lines of source code, compared to 2,377 for the reference implementation, because you're able to express concepts very concisely using Svelte's template syntax (which [takes all of five minutes to master](https://v2.svelte.dev/guide#template-syntax)). You get [scoped CSS](blog/the-zen-of-just-writing-css), with unused style removal and minification built-in, and you can use preprocessors like LESS if you want. You no longer need to use Babel. SSR is ridiculously fast, because it's just string concatenation. And we recently introduced [svelte/store](https://v2.svelte.dev/guide#state-management), a tiny global store that synchronises state across your component hierarchy with zero boilerplate. The worst that can happen is that you'll end up feeling vindicated!\n\nBut there are trade-offs nonetheless. Some people have a pathological aversion to any form of 'template language', and maybe that applies to you. JSX proponents will clobber you with the 'it's just JavaScript' mantra, and therein lies React's greatest strength, which is that it is infinitely flexible. That flexibility comes with its own set of trade-offs, but we're not here to discuss those.\n\nAnd then there's *ecosystem*. The universe around React in particular — the devtools, editor integrations, ancillary libraries, tutorials, StackOverflow answers, hell, even job opportunities — is unrivalled. While it's true that citing 'ecosystem' as the main reason to choose a tool is a sign that you're stuck on a local maximum, apt to be marooned by the rising waters of progress, it's still a major point in favour of incumbents.\n\n\n## Roadmap\n\nWe're not at version 1.0.0 yet, and a few things may change before we get there. Once we do (soon!), there are a lot of exciting possibilities.\n\nI believe the next frontier of web performance is 'whole-app optimisation'. Currently, Svelte's compiler operates at the component level, but a compiler that understood the boundaries *between* those components could generate even more efficient code. The React team's [Prepack research](https://twitter.com/trueadm/status/944908776896978946) is predicated on a similar idea, and the Glimmer team is doing some interesting work in this space. Svelte and Sapper are well positioned to take advantage of these ideas.\n\nSpeaking of Glimmer, the idea of compiling components to bytecode is one that we'll probably steal in 2018. A framework like Sapper could conceivably determine which compilation mode to use based on the characteristics of your app. It could even serve JavaScript for the initial route for the fastest possible startup time, then lazily serve a bytecode interpreter for subsequent routes, resulting in the optimal combination of startup size and total app size.\n\nMostly, though, we want the direction of Sapper to be determined by its users. If you're the kind of developer who enjoys life on the bleeding edge and would like to help shape the future of how we build web apps, please join us on [GitHub](https://github.com/sveltejs/svelte) and [Discord](chat).\n",
	},
];

export const blog_out_full = [
	{
		title: "Sapper: Towards the ideal web app framework",
		slug: "sapper-towards-the-ideal-web-app-framework",
		file: "2017-12-31-sapper-towards-the-ideal-web-app-framework.md",
		content:
			'<blockquote>\n<p>Quickstart for the impatient: <a href="https://sapper.svelte.dev" target="_blank" rel="noopener noreferrer">the Sapper docs</a>, and the <a href="https://github.com/sveltejs/sapper-template" target="_blank" rel="noopener noreferrer">starter template</a></p>\n</blockquote>\n<p>If you had to list the characteristics of the perfect Node.js web application framework, you\'d probably come up with something like this:</p>\n<ol>\n<li>It should do server-side rendering, for fast initial loads and no caveats around SEO</li>\n<li>As a corollary, your app\'s codebase should be universal — write once for server <em>and</em> client</li>\n<li>The client-side app should <em>hydrate</em> the server-rendered HTML, attaching event listeners (and so on) to existing elements rather than re-rendering them</li>\n<li>Navigating to subsequent pages should be instantaneous</li>\n<li>Offline, and other Progressive Web App characteristics, must be supported out of the box</li>\n<li>Only the JavaScript and CSS required for the first page should load initially. That means the framework should do automatic code-splitting at the route level, and support dynamic <code>import(...)</code> for more granular manual control</li>\n<li>No compromise on performance</li>\n<li>First-rate developer experience, with hot module reloading and all the trimmings</li>\n<li>The resulting codebase should be easy to grok and maintain</li>\n<li>It should be possible to understand and customise every aspect of the system — no webpack configs locked up in the framework, and as little hidden \'plumbing\' as possible</li>\n<li>Learning the entire framework in under an hour should be easy, and not just for experienced developers</li>\n</ol>\n<p><a href="https://github.com/zeit/next.js" target="_blank" rel="noopener noreferrer">Next.js</a> is close to this ideal. If you haven\'t encountered it yet, I strongly recommend going through the tutorials at <a href="https://learnnextjs.com" target="_blank" rel="noopener noreferrer">learnnextjs.com</a>. Next introduced a brilliant idea: all the pages of your app are files in a <code>your-project/pages</code> directory, and each of those files is just a React component.</p>\n<p>Everything else flows from that breakthrough design decision. Finding the code responsible for a given page is easy, because you can just look at the filesystem rather than playing \'guess the component name\'. Project structure bikeshedding is a thing of the past. And the combination of SSR (server-side rendering) and code-splitting — something the React Router team <a href="https://reacttraining.com/react-router/web/guides/code-splitting" target="_blank" rel="noopener noreferrer">gave up on</a>, declaring \'Godspeed those who attempt the server-rendered, code-split apps\' — is trivial.</p>\n<p>But it\'s not perfect. As churlish as it might be to list the flaws in something <em>so, so good</em>, there are some:</p>\n<ul>\n<li>Next uses something called \'route masking\' to create nice URLs (e.g. <code>/blog/hello-world</code> instead of <code>/post?slug=hello-world</code>). This undermines the guarantee about directory structure corresponding to app structure, and forces you to maintain configuration that translates between the two forms</li>\n<li>All your routes are assumed to be universal \'pages\'. But it\'s very common to need routes that only render on the server, such as a 301 redirect or an <a href="/blog/sapper-towards-the-ideal-web-app-framework.json" rel="noopener noreferrer">API endpoint</a> that serves the data for your pages, and Next doesn\'t have a great solution for this. You can add logic to your <code>server.js</code> file to handle these cases, but it feels at odds with the declarative approach taken for pages</li>\n<li>To use the client-side router, links can\'t be standard <code>&#x3C;a></code> tags. Instead, you have to use framework-specific <code>&#x3C;Link></code> components, which is impossible in the markdown content for a blog post such as this one, for example</li>\n</ul>\n<p>The real problem, though, is that all that goodness comes for a price. The simplest possible Next app — a single \'hello world\' page that renders some static text — involves 66kb of gzipped JavaScript. Unzipped, it\'s 204kb, which is a non-trivial amount of code for a mobile device to parse at a time when performance is a critical factor determining whether or not your users will stick around. And that\'s the <em>baseline</em>.</p>\n<p>We can do better!</p>\n<h2 id="the-compiler-as-framework-paradigm-shift">The compiler-as-framework paradigm shift</h2>\n<p><a href="blog/frameworks-without-the-framework" rel="noopener noreferrer">Svelte introduced a radical idea</a>: what if your UI framework wasn\'t a framework at all, but a compiler that turned your components into standalone JavaScript modules? Instead of using a library like React or Vue, which knows nothing about your app and must therefore be a one-size-fits-all solution, we can ship highly-optimised vanilla JavaScript. Just the code your app needs, and without the memory and performance overhead of solutions based on a virtual DOM.</p>\n<p>The JavaScript world is <a href="https://tomdale.net/2017/09/compilers-are-the-new-frameworks/" target="_blank" rel="noopener noreferrer">moving towards this model</a>. <a href="https://stenciljs.com" target="_blank" rel="noopener noreferrer">Stencil</a>, a Svelte-inspired framework from the Ionic team, compiles to web components. <a href="https://glimmerjs.com" target="_blank" rel="noopener noreferrer">Glimmer</a> <em>doesn\'t</em> compile to standalone JavaScript (the pros and cons of which deserve a separate blog post), but the team is doing some fascinating research around compiling templates to bytecode. (React is <a href="https://twitter.com/trueadm/status/944908776896978946" target="_blank" rel="noopener noreferrer">getting in on the action</a>, though their current research focuses on optimising your JSX app code, which is arguably more similar to the ahead-of-time optimisations that Angular, Ractive and Vue have been doing for a few years.)</p>\n<p>What happens if we use the new model as a starting point?</p>\n<h2 id="introducing-sapper">Introducing Sapper</h2>\n<aside><p>The <a href="https://sapper.svelte.dev/docs#Why_the_name">name comes from</a> the term for combat engineers, and is also short for Svelte app maker</p></aside>\n<p><a href="https://sapper.svelte.dev" target="_blank" rel="noopener noreferrer">Sapper</a> is the answer to that question. <strong>Sapper is a Next.js-style framework that aims to meet the eleven criteria at the top of this article while dramatically reducing the amount of code that gets sent to the browser.</strong> It\'s implemented as Express-compatible middleware, meaning it\'s easy to understand and customise.</p>\n<p>The same \'hello world\' app that took 204kb with React and Next weighs just 7kb with Sapper. That number is likely to fall further in the future as we explore the space of optimisation possibilities, such as not shipping any JavaScript <em>at all</em> for pages that aren\'t interactive, beyond the tiny Sapper runtime that handles client-side routing.</p>\n<p>What about a more \'real world\' example? Conveniently, the <a href="https://github.com/gothinkster/realworld" target="_blank" rel="noopener noreferrer">RealWorld</a> project, which challenges frameworks to develop an implementation of a Medium clone, gives us a way to find out. The <a href="https://github.com/sveltejs/realworld" target="_blank" rel="noopener noreferrer">Sapper implementation</a> takes 39.6kb (11.8kb zipped) to render an interactive homepage.</p>\n<aside><p>Code-splitting isn\'t free — if the reference implementation used code-splitting, it would be larger still</p></aside>\n<p>The entire app costs 132.7kb (39.9kb zipped), which is significantly smaller than the reference React/Redux implementation at 327kb (85.7kb), but even if it was as large it would <em>feel</em> faster because of code-splitting. And that\'s a crucial point. We\'re told we need to code-split our apps, but if your app uses a traditional framework like React or Vue then there\'s a hard lower bound on the size of your initial code-split chunk — the framework itself, which is likely to be a significant portion of your total app size. With the Svelte approach, that\'s no longer the case.</p>\n<p>But size is only part of the story. Svelte apps are also extremely performant and memory-efficient, and the framework includes powerful features that you would sacrifice if you chose a \'minimal\' or \'simple\' UI library.</p>\n<h2 id="trade-offs">Trade-offs</h2>\n<p>The biggest drawback for many developers evaluating Sapper would be \'but I like React, and I already know how to use it\', which is fair.</p>\n<p>If you\'re in that camp, I\'d invite you to at least try alternative frameworks. You might be pleasantly surprised! The <a href="https://github.com/sveltejs/realworld" target="_blank" rel="noopener noreferrer">Sapper RealWorld</a> implementation totals 1,201 lines of source code, compared to 2,377 for the reference implementation, because you\'re able to express concepts very concisely using Svelte\'s template syntax (which <a href="https://v2.svelte.dev/guide#template-syntax" target="_blank" rel="noopener noreferrer">takes all of five minutes to master</a>). You get <a href="blog/the-zen-of-just-writing-css" rel="noopener noreferrer">scoped CSS</a>, with unused style removal and minification built-in, and you can use preprocessors like LESS if you want. You no longer need to use Babel. SSR is ridiculously fast, because it\'s just string concatenation. And we recently introduced <a href="https://v2.svelte.dev/guide#state-management" target="_blank" rel="noopener noreferrer">svelte/store</a>, a tiny global store that synchronises state across your component hierarchy with zero boilerplate. The worst that can happen is that you\'ll end up feeling vindicated!</p>\n<p>But there are trade-offs nonetheless. Some people have a pathological aversion to any form of \'template language\', and maybe that applies to you. JSX proponents will clobber you with the \'it\'s just JavaScript\' mantra, and therein lies React\'s greatest strength, which is that it is infinitely flexible. That flexibility comes with its own set of trade-offs, but we\'re not here to discuss those.</p>\n<p>And then there\'s <em>ecosystem</em>. The universe around React in particular — the devtools, editor integrations, ancillary libraries, tutorials, StackOverflow answers, hell, even job opportunities — is unrivalled. While it\'s true that citing \'ecosystem\' as the main reason to choose a tool is a sign that you\'re stuck on a local maximum, apt to be marooned by the rising waters of progress, it\'s still a major point in favour of incumbents.</p>\n<h2 id="roadmap">Roadmap</h2>\n<p>We\'re not at version 1.0.0 yet, and a few things may change before we get there. Once we do (soon!), there are a lot of exciting possibilities.</p>\n<p>I believe the next frontier of web performance is \'whole-app optimisation\'. Currently, Svelte\'s compiler operates at the component level, but a compiler that understood the boundaries <em>between</em> those components could generate even more efficient code. The React team\'s <a href="https://twitter.com/trueadm/status/944908776896978946" target="_blank" rel="noopener noreferrer">Prepack research</a> is predicated on a similar idea, and the Glimmer team is doing some interesting work in this space. Svelte and Sapper are well positioned to take advantage of these ideas.</p>\n<p>Speaking of Glimmer, the idea of compiling components to bytecode is one that we\'ll probably steal in 2018. A framework like Sapper could conceivably determine which compilation mode to use based on the characteristics of your app. It could even serve JavaScript for the initial route for the fastest possible startup time, then lazily serve a bytecode interpreter for subsequent routes, resulting in the optimal combination of startup size and total app size.</p>\n<p>Mostly, though, we want the direction of Sapper to be determined by its users. If you\'re the kind of developer who enjoys life on the bleeding edge and would like to help shape the future of how we build web apps, please join us on <a href="https://github.com/sveltejs/svelte" target="_blank" rel="noopener noreferrer">GitHub</a> and <a href="chat" rel="noopener noreferrer">Discord</a>.</p>',
		date: {
			pretty: "Sun Dec 31 2017",
			numeric: "2017-12-31",
		},
		description: "Taking the next-plus-one step",
		author: {
			name: 'Rich Harris',
			url: 'https://twitter.com/Rich_Harris'
		},
		draft: false
	},
	{
		title: "The zen of Just Writing CSS",
		slug: "the-zen-of-just-writing-css",
		file: "2017-09-06-the-zen-of-just-writing-css.md",
		content:
			'<p>It\'s fashionable to dislike CSS. There are lots of reasons why that\'s the case, but it boils down to this: CSS is <em>unpredictable</em>. If you\'ve never had the experience of tweaking a style rule and accidentally breaking some layout that you thought was completely unrelated — usually when you\'re trying to ship — then you\'re either new at this or you\'re a much better programmer than the rest of us.</p>\n<p>So the JavaScript community rolled up its sleeves and got to work. Over the last couple of years, there\'s been a Cambrian explosion of libraries aimed at making CSS behave, collectively referred to as <em>CSS-in-JS</em>.</p>\n<p>What you might not realise is that <strong>the biggest problems with CSS can be solved without CSS-in-JS</strong>. Without those problems, writing CSS isn\'t just tolerable — it\'s enjoyable. And you don\'t have to find solutions to the additional problems that CSS-in-JS introduces.</p>\n<p>This article isn\'t in any way intended as criticism of the hard work the CSS-in-JS community has done. It\'s one of the most active corners of the JS ecosystem, and new ideas are springing up every week. Instead, my purpose is to illustrate why an alternative approach — based on Single File Components with real CSS — is so damn delightful.</p>\n<h2 id="the-biggest-problem-with-css">The biggest problem with CSS</h2>\n<p>Everything in CSS is global. Because of that, styles intended for one bit of markup often end up affecting another. Because of <em>that</em>, developers often resort to wild namespacing conventions (not \'rules\', since they\'re very difficult to enforce) that mostly just increase your risk of RSI.</p>\n<p>It gets worse when you\'re working on a team. No-one dares touch styles authored by someone else, because it\'s often unclear what they\'re doing, what markup they apply to, and what disasters will unfold if you remove them.</p>\n<p>The consequence of all this is the <strong>append-only stylesheet</strong>. There\'s no way of knowing which code can safely be removed, so it\'s common to undo some existing style with another, more specific style — even on relatively small projects.</p>\n<h2 id="single-file-components-change-all-that">Single File Components change all that</h2>\n<p>The idea behind SFCs is simple: you write your components in an HTML file that (optionally) contains a <code>&#x3C;style></code> and <code>&#x3C;script></code> attribute describing the component\'s styles and behaviour. Svelte, Ractive, Vue and Polymer all follow this basic pattern.</p>\n<aside>\n\t<p><a href="blog/frameworks-without-the-framework">Read the introductory blog post</a> if you\'re new to Svelte. Or <a href="https://twitter.com/padolsey/status/899717303234908160">read</a> <a href="https://twitter.com/sveltejs/status/901818357644701696">the</a> <a href="https://twitter.com/sveltejs/status/901818106309476352">testimonials</a>.</p>\n</aside>\n<p>(For the rest of this article we\'ll be using Svelte, obviously. But if the idea of using a template language makes you shudder — your fears are misplaced, but that\'s a topic for another day — then just use Vue which lets you use JSX in your SFCs.)</p>\n<p>Several wonderful things happen as a result:</p>\n<ul>\n<li>Your styles are <em>scoped to the component</em>. No more leakage, no more unpredictable cascade. And no more sesquipedalian classnames designed to prevent conflicts.</li>\n<li>You don\'t need to go spelunking through your folder structure to find the rules that are breaking your stuff.</li>\n<li>The compiler (in Svelte\'s case) can <strong>identify and remove unused styles</strong>. No more append-only stylesheets!</li>\n</ul>\n<p>Let\'s see what that looks like in practice.</p>\n<figure>\n\t<video controls poster=\'https://svelte-technology-assets.surge.sh/just-write-css.jpg\'>\n\t\t<source type=\'video/mp4\' src=\'https://svelte-technology-assets.surge.sh/just-write-css.mp4\'>\n\t</video>\n<div class="code-block"><pre class=\'language-undefined\'><code>&lt;figcaption&gt;\n\tIs this what they mean by \'use the platform\'?\n&lt;/figcaption&gt;</code></pre></div>\n</figure>\n<p>Every code editor already knows about CSS, so there\'s a good chance that you\'ll get autocomplete, linting, syntax highlighting and so on — all without additional JS-fatigue-inducing tools.</p>\n<p>And because it\'s real CSS, rather than some camelCased quotes-everywhere impostor, we can take advantage of the \'tweak in devtools, paste back into our source code\' workflow, which I personally couldn\'t live without. Notice that we get CSS sourcemaps out of the box, so you can instantly pinpoint the lines in question. It\'s hard to overstate the importance of this: when you\'re in WYSIWYG mode, you\'re not thinking in terms of your component tree, so having a robust way to figure out <em>where these damn styles came from</em> is essential. Doubly so if someone else originally wrote the component. (I promise you, this is the single biggest productivity boost to your CSS workflow. If you\'re writing styles without sourcemaps, you are almost certainly wasting a lot of time. I know I was.)</p>\n<p>Svelte transforms your selectors (using an attribute that\'s also applied to affected elements, though the exact mechanism is unimportant and subject to change) to achieve the scoping. It warns on and removes any unused rules, then it minifies the result and lets you write it out to a <code>.css</code> file. There\'s also an experimental new option to compile to web components, using shadow DOM to encapsulate the styles, if that\'s your jam.</p>\n<p>This is all possible because your CSS is parsed (with <a href="https://github.com/csstree/csstree" target="_blank" rel="noopener noreferrer">css-tree</a>) and statically analysed in the context of your markup. Static analysis opens the doors to all kinds of exciting future possibilities — smarter optimisations, a11y hints — that are much harder if your styles are computed dynamically at runtime. We\'re just getting started.</p>\n<h2 id="but-we-can-add-tools-to-do-x">But we can add tools to do [x]!</h2>\n<p>If your reaction to the video was \'fine, but if we use TypeScript and write plugins for each editor then we can get all the autocomplete and syntax highlighting stuff\' — in other words, if you believe that in order to achieve parity with CSS it makes sense to build, document, promote and maintain a fleet of ancillary projects — then, well, you and I may never see eye to eye!</p>\n<h2 id="we-don-t-have-all-the-answers-yet">We don\'t have all the answers — yet</h2>\n<p>Having said all that, CSS-in-JS does point to answers to some lingering questions:</p>\n<ul>\n<li>How can we install styles from npm?</li>\n<li>How can we reuse constants that are defined in a single place?</li>\n<li>How can we compose declarations?</li>\n</ul>\n<p>Personally, I haven\'t found these issues to outweigh the benefits of the approach outlined above. You may well have a different set of priorities, and they may be reason enough for you to abandon CSS.</p>\n<p>But at the end of the day, you have to know CSS anyway. Love it or loathe it, you must at least <em>learn</em> it. As custodians of the web, we have a choice: create abstractions that steepen the web dev learning curve yet further, or work together to fix the bad parts of CSS. I know which I choose.</p>',
		date: {
			pretty: "Wed Sep 06 2017",
			numeric: "2017-09-06",
		},
		description: "I would say this is the future, but we're already doing it.",
		author: {
			name: 'Rich Harris',
			url: 'https://twitter.com/Rich_Harris'
		},
		draft: false
	},
	{
		title: "The easiest way to get started with Svelte",
		slug: "the-easiest-way-to-get-started",
		file: "2017-08-07-the-easiest-way-to-get-started.md",
		content:
			'<p>Svelte is a <a href="/blog/frameworks-without-the-framework" rel="noopener noreferrer">new kind of framework</a>. Rather than putting a <code>&#x3C;script src=\'svelte.js\'></code> tag on the page, or bringing it into your app with <code>import</code> or <code>require</code>, Svelte is a compiler that works behind the scenes to turn your component files into beautifully optimised JavaScript.</p>\n<p>Because of that, getting started with it can be a little bit confusing at first. How, you might reasonably ask, do you make a Svelte app?</p>\n<h2 id="1-use-the-repl">1. Use the REPL</h2>\n<p>The <a href="repl" rel="noopener noreferrer">Svelte REPL</a> is the easiest way to begin. You can choose from a list of examples to get you started, and tweak them until they do what you want.</p>\n<aside><p>You\'ll need to have <a href="https://nodejs.org/">Node.js</a> installed, and know how to use the terminal</p></aside>\n<p>At some point, your app will outgrow the REPL. Click the <strong>download</strong> button to save a <code>svelte-app.zip</code> file to your computer and uncompress it.</p>\n<p>Open a terminal window and set the project up...</p>\n<div class="code-block"><pre class=\'language-bash\'><code><span class="token builtin class-name">cd</span> /path/to/svelte-app\n<span class="token function">npm</span> <span class="token function">install</span></code></pre></div>\n<p>...then start up a development server:</p>\n<div class="code-block"><pre class=\'language-bash\'><code><span class="token function">npm</span> run dev</code></pre></div>\n<p>This will serve your app on <a href="http://localhost:5000" target="_blank" rel="noopener noreferrer">localhost:5000</a> and rebuild it with <a href="https://rollupjs.org" target="_blank" rel="noopener noreferrer">Rollup</a> every time you make a change to the files in <code>svelte-app/src</code>.</p>\n<h2 id="2-use-degit">2. Use degit</h2>\n<p>When you download from the REPL, you\'re getting a customised version of the <a href="https://github.com/sveltejs/template" target="_blank" rel="noopener noreferrer">sveltejs/template</a> repo. You can skip messing around with zip files by using <a href="https://github.com/Rich-Harris/degit" target="_blank" rel="noopener noreferrer">degit</a>, a project scaffolding tool.</p>\n<p>In the terminal, you can instantly create a new project like so:</p>\n<div class="code-block"><pre class=\'language-bash\'><code>npx degit sveltejs/template my-svelte-project\n<span class="token builtin class-name">cd</span> my-svelte-project\n<span class="token function">npm</span> <span class="token function">install</span>\n<span class="token function">npm</span> run dev</code></pre></div>\n<p>This will create a new project in the <code>my-svelte-project</code> directory, install its dependencies, and start a server on <a href="http://localhost:5000" target="_blank" rel="noopener noreferrer">http://localhost:5000</a>.</p>\n<p>Once you\'ve tinkered a bit and understood how everything fits together, you can fork <a href="https://github.com/sveltejs/template" target="_blank" rel="noopener noreferrer">sveltejs/template</a> and start doing this instead:</p>\n<div class="code-block"><pre class=\'language-bash\'><code>npx degit your-name/template my-new-project</code></pre></div>\n<p>And that\'s it! Do <code>npm run build</code> to create a production-ready version of your app, and check the project template\'s <a href="https://github.com/sveltejs/template/blob/master/README.md" target="_blank" rel="noopener noreferrer">README</a> for instructions on how to easily deploy your app to the web with <a href="https://zeit.co/now" target="_blank" rel="noopener noreferrer">Now</a> or <a href="http://surge.sh/" target="_blank" rel="noopener noreferrer">Surge</a>.</p>\n<p>You\'re not restricted to using Rollup — there are also integrations for <a href="https://github.com/sveltejs/svelte-loader" target="_blank" rel="noopener noreferrer">webpack</a>, <a href="https://github.com/tehshrike/sveltify" target="_blank" rel="noopener noreferrer">Browserify</a> and others, or you can use the <a href="https://github.com/sveltejs/svelte-cli" target="_blank" rel="noopener noreferrer">Svelte CLI</a> (Update from 2019: with Svelte 3 the CLI was deprecated and we now use <a href="https://www.npmjs.com/package/sirv-cli" target="_blank" rel="noopener noreferrer">sirv-cli</a> in our template. Feel free to use whatever tool you like!) or the <a href="https://github.com/sveltejs/svelte/tree/v2#api" target="_blank" rel="noopener noreferrer">API</a> directly. If you make a project template using one of these tools, please share it with the <a href="chat" rel="noopener noreferrer">Svelte Discord chatroom</a>, or via <a href="https://twitter.com/sveltejs" target="_blank" rel="noopener noreferrer">@sveltejs</a> on Twitter!</p>',
		date: {
			pretty: "Mon Aug 07 2017",
			numeric: "2017-08-07",
		},
		description: "This'll only take a minute.",
		author: {
			name: 'Rich Harris',
			url: 'https://twitter.com/Rich_Harris'
		},
		draft: false
	},
	{
		title:
			"Frameworks without the framework: why didn't we think of this sooner?",
		slug: "frameworks-without-the-framework",
		file: "2016-11-26-frameworks-without-the-framework.md",
		content:
			'<blockquote>\n<p>Wait, this new framework has a <em>runtime</em>? Ugh. Thanks, I\'ll pass.\n<strong>– front end developers in 2018</strong></p>\n</blockquote>\n<p>We\'re shipping too much code to our users. Like a lot of front end developers, I\'ve been in denial about that fact, thinking that it was fine to serve 100kb of JavaScript on page load – just use <a href="https://twitter.com/miketaylr/status/227056824275333120" target="_blank" rel="noopener noreferrer">one less .jpg!</a> – and that what <em>really</em> mattered was performance once your app was already interactive.</p>\n<p>But I was wrong. 100kb of .js isn\'t equivalent to 100kb of .jpg. It\'s not just the network time that\'ll kill your app\'s startup performance, but the time spent parsing and evaluating your script, during which time the browser becomes completely unresponsive. On mobile, those milliseconds rack up very quickly.</p>\n<p>If you\'re not convinced that this is a problem, follow <a href="https://twitter.com/slightlylate" target="_blank" rel="noopener noreferrer">Alex Russell</a> on Twitter. Alex <a href="https://twitter.com/slightlylate/status/728355959022587905" target="_blank" rel="noopener noreferrer">hasn\'t been making many friends in the framework community lately</a>, but he\'s not wrong. But the proposed alternative to using frameworks like Angular, React and Ember – <a href="https://www.polymer-project.org/1.0/" target="_blank" rel="noopener noreferrer">Polymer</a> – hasn\'t yet gained traction in the front end world, and it\'s certainly not for a lack of marketing.</p>\n<p>Perhaps we need to rethink the whole thing.</p>\n<h2 id="what-problem-do-frameworks-really-solve">What problem do frameworks <em>really</em> solve?</h2>\n<p>The common view is that frameworks make it easier to manage the complexity of your code: the framework abstracts away all the fussy implementation details with techniques like virtual DOM diffing. But that\'s not really true. At best, frameworks <em>move the complexity around</em>, away from code that you had to write and into code you didn\'t.</p>\n<p>Instead, the reason that ideas like React are so wildly and deservedly successful is that they make it easier to manage the complexity of your <em>concepts</em>. Frameworks are primarily a tool for structuring your thoughts, not your code.</p>\n<p>Given that, what if the framework <em>didn\'t actually run in the browser</em>? What if, instead, it converted your application into pure vanilla JavaScript, just like Babel converts ES2016+ to ES5? You\'d pay no upfront cost of shipping a hefty runtime, and your app would get seriously fast, because there\'d be no layers of abstraction between your app and the browser.</p>\n<h2 id="introducing-svelte">Introducing Svelte</h2>\n<p>Svelte is a new framework that does exactly that. You write your components using HTML, CSS and JavaScript (plus a few extra bits you can <a href="https://v2.svelte.dev/guide" target="_blank" rel="noopener noreferrer">learn in under 5 minutes</a>), and during your build process Svelte compiles them into tiny standalone JavaScript modules. By statically analysing the component template, we can make sure that the browser does as little work as possible.</p>\n<p>The <a href="https://svelte-todomvc.surge.sh/" target="_blank" rel="noopener noreferrer">Svelte implementation of TodoMVC</a> weighs 3.6kb zipped. For comparison, React plus ReactDOM <em>without any app code</em> weighs about 45kb zipped. It takes about 10x as long for the browser just to evaluate React as it does for Svelte to be up and running with an interactive TodoMVC.</p>\n<p>And once your app <em>is</em> up and running, according to <a href="https://github.com/krausest/js-framework-benchmark" target="_blank" rel="noopener noreferrer">js-framework-benchmark</a> <strong>Svelte is fast as heck</strong>. It\'s faster than React. It\'s faster than Vue. It\'s faster than Angular, or Ember, or Ractive, or Preact, or Riot, or Mithril. It\'s competitive with Inferno, which is probably the fastest UI framework in the world, for now, because <a href="https://twitter.com/trueadm" target="_blank" rel="noopener noreferrer">Dominic Gannaway</a> is a wizard. (Svelte is slower at removing elements. We\'re <a href="https://github.com/sveltejs/svelte/issues/26" target="_blank" rel="noopener noreferrer">working on it</a>.)</p>\n<p>It\'s basically as fast as vanilla JS, which makes sense because it <em>is</em> vanilla JS – just vanilla JS that you didn\'t have to write.</p>\n<h2 id="but-that-s-not-the-important-thing">But that\'s not the important thing</h2>\n<p>Well, it <em>is</em> important – performance matters a great deal. What\'s really exciting about this approach, though, is that we can finally solve some of the thorniest problems in web development.</p>\n<p>Consider interoperability. Want to <code>npm install cool-calendar-widget</code> and use it in your app? Previously, you could only do that if you were already using (a correct version of) the framework that the widget was designed for – if <code>cool-calendar-widget</code> was built in React and you\'re using Angular then, well, hard cheese. But if the widget author used Svelte, apps that use it can be built using whatever technology you like. (On the TODO list: a way to convert Svelte components into web components.)</p>\n<p>Or <a href="https://twitter.com/samccone/status/797528710085652480" target="_blank" rel="noopener noreferrer">code splitting</a>. It\'s a great idea (only load the code the user needs for the initial view, then get the rest later), but there\'s a problem – even if you only initially serve one React component instead of 100, <em>you still have to serve React itself</em>. With Svelte, code splitting can be much more effective, because the framework is embedded in the component, and the component is tiny.</p>\n<p>Finally, something I\'ve wrestled with a great deal as an open source maintainer: your users always want <em>their</em> features prioritised, and underestimate the cost of those features to people who don\'t need them. A framework author must always balance the long-term health of the project with the desire to meet their users\' needs. That\'s incredibly difficult, because it\'s hard to anticipate – much less articulate – the consequences of incremental bloat, and it takes serious soft skills to tell people (who may have been enthusiastically evangelising your tool up to that point) that their feature isn\'t important enough. But with an approach like Svelte\'s, many features can be added with absolutely no cost to people who don\'t use them, because the code that implements those features just doesn\'t get generated by the compiler if it\'s unnecessary.</p>\n<h2 id="we-re-just-getting-started">We\'re just getting started</h2>\n<p>Svelte is very new. There\'s a lot of work still left to do – creating build tool integrations, adding a server-side renderer, hot reloading, transitions, more documentation and examples, starter kits, and so on.</p>\n<p>But you can already build rich components with it, which is why we\'ve gone straight to a stable 1.0.0 release. <a href="https://v2.svelte.dev/guide" target="_blank" rel="noopener noreferrer">Read the guide</a>, <a href="/repl" rel="noopener noreferrer">try it out in the REPL</a>, and head over to <a href="https://github.com/sveltejs/svelte" target="_blank" rel="noopener noreferrer">GitHub</a> to help kickstart the next era of front end development.</p>',
		date: {
			pretty: "Sat Nov 26 2016",
			numeric: "2016-11-26",
		},
		description: "You can't write serious applications in vanilla JavaScript without hitting a complexity wall. But a compiler can do it for you.",
		author: {
			name: 'Rich Harris',
			url: 'https://twitter.com/Rich_Harris'
		},
		draft: false
	},
];

export const blog_out_list = [
	{
		title: "Sapper: Towards the ideal web app framework",
		slug: "sapper-towards-the-ideal-web-app-framework",
		file: "2017-12-31-sapper-towards-the-ideal-web-app-framework.md",
		date: {
			pretty: "Sun Dec 31 2017",
			numeric: "2017-12-31",
		},
		description: "Taking the next-plus-one step",
		author: {
			name: 'Rich Harris',
			url: 'https://twitter.com/Rich_Harris'
		},
		draft: false
	},
	{
		title: "The zen of Just Writing CSS",
		slug: "the-zen-of-just-writing-css",
		file: "2017-09-06-the-zen-of-just-writing-css.md",
		date: {
			pretty: "Wed Sep 06 2017",
			numeric: "2017-09-06",
		},
		description: "I would say this is the future, but we're already doing it.",
		author: {
			name: 'Rich Harris',
			url: 'https://twitter.com/Rich_Harris'
		},
		draft: false
	},
	{
		title: "The easiest way to get started with Svelte",
		slug: "the-easiest-way-to-get-started",
		file: "2017-08-07-the-easiest-way-to-get-started.md",
		date: {
			pretty: "Mon Aug 07 2017",
			numeric: "2017-08-07",
		},
		description: "This'll only take a minute.",
		author: {
			name: 'Rich Harris',
			url: 'https://twitter.com/Rich_Harris'
		},
		draft: false
	},
	{
		title:
			"Frameworks without the framework: why didn't we think of this sooner?",
		slug: "frameworks-without-the-framework",
		file: "2016-11-26-frameworks-without-the-framework.md",
		date: {
			pretty: "Sat Nov 26 2016",
			numeric: "2016-11-26",
		},
		description: "You can't write serious applications in vanilla JavaScript without hitting a complexity wall. But a compiler can do it for you.",
		author: {
			name: 'Rich Harris',
			url: 'https://twitter.com/Rich_Harris'
		},
		draft: false
	},
];
